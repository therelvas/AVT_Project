<html>

<head>
<title>Frogger WebGL</title>

<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="fragmentShader.glsl.js"></script>
<script type="text/javascript" src="vertexShader.glsl.js"></script>
<script type="text/javascript" src="cube.js"></script>
<script type="text/javascript" src="sphere.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="car.js"></script>
<script type="text/javascript" src="turtle.js"></script>
<script type="text/javascript" src="roadMargin.js"></script>
<script type="text/javascript" src="road.js"></script>
<script type="text/javascript" src="riverMargin.js"></script>
<script type="text/javascript" src="river.js"></script>
<script type="text/javascript" src="light.js"></script>
<script type="text/javascript" src="fog.js"></script>
<script type="text/javascript" src="obstacles.js"></script>
<script type="text/javascript" src="utils.js"></script>

<script type="text/javascript">

	//GL and Shader
    var gl;
    var shaderProgram;

    //Camera
    var view = 1;
    var camera;

    var camX = 0.0;
    var camY = 0.0;
    var camZ = 0.0;

    //Lights
    var light;

	//Fog
	var fog;
	
    //Scenario
    var road;
    var roadMargin;
    var riverMargin1;
    var riverMargin2;
    var river;

    //Enemies
    var obstacles;

    //Keyboard/Mouse
    var mouseDown = false;
    var tracking = false;

    var startX = 0;
    var startY = 0;

    var alpha = -90.0;
    var beta = 25.0;
    var r = 10.0;

    //Matrices
    var mMatrix = mat4.create(); //Model Matrix
    var vMatrix = mat4.create(); //View Matrix
    var pMatrix = mat4.create(); //Projection Matrix

    var mMatrixStack = [];

    // ------------------------------------------------------------
    //
    // Matrices stuff
    //

    function pushMatrix() {
        var copy = mat4.create();
        mat4.set(mMatrix, copy);
        mMatrixStack.push(copy);
    }


    function popMatrix() {
        if (mMatrixStack.length == 0) {
            throw "Invalid popMatrix";
        }
        mMatrix = mMatrixStack.pop();
    }


    function sendMatricesToGL() {

    	var vmMatrix = mat4.create();
    	mat4.multiply(vMatrix, mMatrix, vmMatrix);

    	var pvmMatrix = mat4.create();
    	mat4.multiply(pMatrix, vmMatrix, pvmMatrix);

        gl.uniformMatrix4fv(shaderProgram.pvmMatrixUniform, false, pvmMatrix);
        gl.uniformMatrix4fv(shaderProgram.vmMatrixUniform, false, vmMatrix);
        
        var normalMatrix = mat3.create();
        normalMatrix = computeNormalMatrix3x3(vmMatrix);
        gl.uniformMatrix3fv(shaderProgram.normalMatrixUniform, false, normalMatrix);
    }

    // ------------------------------------------------------------
    //
    // Render stufff
    //

    function renderScene() {
        
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        //Destroy obstacles
        obstacles.destroyObstacles();

        camera.draw(0.0, 3.0, 50.0, camX, camY, camZ);

        light.draw();
        fog.draw();

        obstacles.updatePosition();
        obstacles.render();

        roadMargin.render();
        road.render();

        riverMargin1.render();
        riverMargin2.render();
                
        river.render();
    }

    // ------------------------------------------------------------
    //
    // Callback display function
    //

    function display() {

        requestAnimFrame(display);

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        renderScene();
    }

    // ------------------------------------------------------------
    //
    // Keyboard events
    //

    function handleKeyDown(event) {

        var key = String.fromCharCode(event.keyCode);

        switch(key) {
            case "A":
                break;
            case "Q":
                break;
            case "O":
                break;
            case "P":
                break;
            case "S":
                break;
            case "1":
                camera.setView(1);
                break;
            case "2":
                camera.setView(2);
                break
            case "3":
                camera.setView(3);
                break
            case "N":
                light.switchLight(0);
                light.switchLight(7);
                break;
            case "C":
                light.switchLight(1);
                light.switchLight(2);
                light.switchLight(3);
                light.switchLight(4);
                light.switchLight(5);
                light.switchLight(6);
                break;
            case "R":
                break;
            case "F":
                fog.switchFog();
		        break;
        }
    }

    // ------------------------------------------------------------
    //
    // Mouse events
    //

    function handleMouseDown(event) {
        
        mouseDown = true;

        startX = event.clientX;
        startY = event.clientY;

        switch(event.which) {
            case 1:
                tracking = 1;
                break;
            case 3:
                tracking = 2;
                break;
        }
    }

    function handleMouseUp(event) {
        
        mouseDown = false;

        if (tracking == 1) {
            alpha -= (event.clientX - startX);
            beta += (event.clientY - startY);
        }
        else if (tracking == 2) {
            r += (event.clientY - startY) * 0.01;
            if(r < 0.1)
                r = 0.1;
        }
        tracking = 0;
    }

    function handleMouseMove(event) {

        var deltaX, deltaY;
        var alphaAux, betaAux;
        var rAux;

        deltaX = -(event.clientX) + startX;
        deltaY = event.clientY - startY;

        if (tracking == 1) {

            alphaAux = alpha + deltaX;
            betaAux = beta + deltaY;

            if(beta > 85.0)
                betaAux = 85.0;
            else if(betaAux < -85.0)
                betaAux = -85.0;
            rAux = r;
        }
        else if (tracking == 2) {

            alphaAux = alpha;
            betaAux = beta;
            rAux = r + (deltaY * 0.01);
            if(rAux < 0.1)
                rAux = 0.1;            
        }

        if(tracking != 0) {
          
            camX = rAux * Math.sin(alphaAux * 3.14 / 180.0) * Math.cos(betaAux * 3.14 / 180.0);
            camZ = rAux * Math.cos(alphaAux * 3.14 / 180.0) * Math.cos(betaAux * 3.14 / 180.0);
            camY = rAux *                                     Math.sin(betaAux * 3.14 / 180.0);
        }
    }

    // --------------------------------------------------------
    //
    // Shader Stuff
    //

    function setupShaders() {

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);

        gl.shaderSource(fragmentShader, fragmentShaderSrc);
        gl.compileShader(fragmentShader);

        if(!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(fragmentShader));
            return null;
        }

        gl.shaderSource(vertexShader, vertexShaderSrc);
        gl.compileShader(vertexShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(vertexShader));
            return null;
        }

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "vertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "vertexNormal");
        gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
        shaderProgram.texCoordinatesAttribute = gl.getAttribLocation(shaderProgram, "texCoordinates");
        gl.enableVertexAttribArray(shaderProgram.texCoordinatesAttribute);

        //Matrices
        shaderProgram.pvmMatrixUniform = gl.getUniformLocation(shaderProgram, "m_pvm");
        shaderProgram.vmMatrixUniform = gl.getUniformLocation(shaderProgram, "m_viewModel");
        shaderProgram.normalMatrixUniform = gl.getUniformLocation(shaderProgram, "m_normal");
    }

    // ------------------------------------------------------------
    //
    // Object creation
    //

    function setupObjects() {

        camera = new Camera(gl.viewportWidth, gl.viewportHeight, view);
       
        roadMargin = new RoadMargin(2.0, -1.0, 50.0);
        road = new Road(9.0, -1.0, 50.0);
        riverMargin1 = new RiverMargin(16.0, -1.0, 50.0);
        river = new River(23.0, -1.0, 50.0);
        riverMargin2 = new RiverMargin(30.0, -1.0, 50.0);

        obstacles = new Obstacles();
        fog = new Fog();
        
        light = new Light();
        light.addLight("directional", [0.0, 10.0, 0.0, 0.0], 0.0, 0.0, 0);

        light.addLight("spot", [5.0, 6.0, 4.0, 1.0],   [0.0, -1.0, 0.0, 0.0], 0.90, 1);
        light.addLight("spot", [13.0, 6.0, 16.0, 1.0], [0.0, -1.0, 0.0, 0.0], 0.90, 2);
        light.addLight("spot", [5.0, 6.0, 36.0, 1.0],  [0.0, -1.0, 0.0, 0.0], 0.90, 3);
        light.addLight("spot", [13.0, 6.0, 56.0, 1.0], [0.0, -1.0, 0.0, 0.0], 0.90, 4);
        light.addLight("spot", [5.0, 6.0, 76.0, 1.0],  [0.0, -1.0, 0.0, 0.0], 0.90, 5);
        light.addLight("spot", [13.0, 6.0, 96.0, 1.0], [0.0, -1.0, 0.0, 0.0], 0.90, 6);

        light.addLight("spot", [0.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0], 0.90, 7);
    }

    // ------------------------------------------------------------
    //
    // General setup
    //

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");

            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {}
        if (!gl) {
            alert("Could not initialise WebGL");
        }
    }


    function setupWebGL() {

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }


    function webGLStart() {
        
    	var canvas = document.createElement('canvas');
		canvas.id = "frogger-webgl";
		canvas.width = 0.98*window.innerWidth;
		canvas.height = 0.97*window.innerHeight;
		document.body.appendChild(canvas);

        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp
        document.onmousemove = handleMouseMove;
       
        document.onkeydown = handleKeyDown;
        
        initGL(canvas);
        setupShaders();
        setupObjects();
        setupWebGL();

        display();
    }

</script>

</head>

<body onload="webGLStart();" oncontextmenu="return false;">  

</html>
